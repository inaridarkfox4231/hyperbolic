step1: 円を表示する
step2: クリックした場所に円を描く（直径はとりあえず10でいい）
step3: クリックで点を排除できるようにする。
step3.1: 点を追加するモードと点を削除するモードの切り替えができるようにし、
         点を削除するモードの時はクリックしても点が追加されないようにする。
step3.2: 点を削除するメソッドを追加する。
step4: 線を引く・・点を二つ選んでそれらを結ぶ直線が追加されるようにする。
       ここは点から線への参照が欲しいところ。もちろん線から点への参照も。
       重複して直線が登録されないようにする工夫が必要。

arc関数の復習：(中心のx, 中心のy, 横幅、縦幅、始端角度、終端角度). あとはnoFillにしといてね。
角度ごちゃごちゃするのやめた。どうせ黒だから円弧でいいや。

step4.1: 点をクリックすると赤くなる
step4:2: 他の点をクリックすると赤い点とその点を結ぶ直線が追加される。
step4.3: 赤い点が固定されてるうちは他の点をクリックするたびに然るべく直線が追加される。
step4.4: 赤い点をクリックするとキャンセルになり赤い点を選ぶところからやり直し。
step4.5: 他のモードに変更すると点が赤いのとかリセットになる。
step5: 線を消す・・点と直線の距離の公式（ポアンカレ平面版）を使って消す。その上の点とかは残る。
       参照も消さないといけない。
2019/07/01現在
直線に点の情報を持たせるのはとりあえず保留。で、直線消すところまで行ったよ。
直線上に点を打つの面白いかも。
今やりたいのは、
1. 直線に点の情報を乗せる。で、重複を防ぐ。
   まず、点をクリックしたときに、その点から延びる直線を走査して、その中にactiveな点を含むものがあれば、
   その直線は既に存在しているので重複して登録されない、というようにする。
   で、そのためには点とか直線に接続のパラメータを持たせないといけないの。
   直線を引くときに直線に点のidを持たせて点に直線のidを持たせる。
   点を消すときは、点から延びている直線からその点のid情報を削除する（メソッドで分離）。
   点の方は特に何もしなくても問題ない（存在が消えるので）。
   直線を消すときは、直線上の点からその直線のid情報を削除する（メソッドで分離）。
   直線の方は問題ない、何もしなくても。
   どちらも.connectedとidを使って操作するから同じメソッドでいけるはず。別々に用意せずとも。
   というか、他にも共通化できるところありそう・・
2. 直線上に点を配置、クリックしたところに置かれる。
3. 直線上の点をクリックして、それら2点の間の点を等間隔に配置する。
4. activeな点とクリックした点に対して、activeな点からクリックした点に延びている直線を基準とし、
   他にも伸びている直線があればそれらを等角度になるように再配置する。（具体的には削除して引き直す）
   つまり、点から出ている直線の本数でもって何等分するか決める感じ。
5. 円の中心に点を置く、地味だけどそういうのも欲しい感じ。
6. ドラッグして平行移動・・どうするのがいいんだろうね。
7. 0をrexp(ia)に移す変換があって、点についてはそれを使う。直線については、多分ね、
   直線の付加情報としてそれを引いたときの点の座標（基準点）を持たせておいて（generatorという）、
   それを移したうえでもっかい引けばいいと思う。その際、点も直線も相互関係を保つようにすること（id, connectedを変えない）。

どうでもいいかもだけど点のidを偶数にして線のidを奇数にした。
対称変換やるとき、どれについて対称やったらどれになるかってのをリストにしておいて重複が起きないように
出来るかもしれないからそれを見越したうえで一応、無駄かもだけど。
点に関して点の対称移動、点に関して線の対称移動(？)、線に関して点の対称移動（反転）、線に関して線の・・いろいろ。
symPwithP: 点を使って点を対称移動
symLwithP: 点を使って直線を点対称移動
mirrorPwithL: 直線を使って点を対称移動（いわゆる鏡映）
mirrorLwithL: 直線を使って直線を対称移動（鏡映で直線を移す）

あとね・・ボタンの更新とか再上げめんどくさいからやっぱweb上に落とした方がいいかな・・ボールの時みたいに。

methodの重複が多すぎるから処理を分解したい。
type0: 点をクリックしてから点をクリックする、activeな点をクリックするとaction
type1: 点をクリックしてから点をクリックする、activeでない点をクリックするとaction
type2: 線をクリックしてから線をクリックする、activeな線をクリックするとaction
type3: 線をクリックしてから線をクリックする、activeでない線をクリックするとaction
type4: 線をクリックしてから点をクリックする、activeでない点をクリックするとaction
type5: 点をクリックしてから線をクリックする、activeでない線をクリックするとaction
1, 2, 3, 7, 8, 9をこれで分類できる。
symPwithPはtype1に相当。symLwithPはtype5.
mirrorPwithLはtype4. mirrorLwithLはintersectionと同じでtype3にあたるね。だからまとめて書かないと。
双方同じタイプの場合（点と点、線と線）のときと違う場合（点と線、線と点）で書き方が違うっぽい。
それで多分4種類くらいになる・・かも？

まず、クリックする。
indexとして点のそれと線のそれを毎回取得する。どっちが優先されるかとか決めておく。
いや・・んー。
点をクリックしてから線をクリック、これ万が一点が線の上だったらキャンセルできなくなっちゃう。だから、
必ず点が先に反応しないといけない。垂線のメソッドも点が先に反応することで垂直2等分線が引けるように
してある。つまり常に点が先に反応するってことね。そして反応するIndexだけが処理においては使われる。
使うのはそのIndexだけってこと・・つまり、点と線のIndex（点だけ、線だけ、点と線の両方の3Type）を取得、
各Typeにおいて-1しかなければreturn, 両方とも>=0の場合は点の方が優先される、あれ、それだと・・
activeなあれがない場合・・んー。各メソッドにおいて点がactiveになるか線がactiveになるかのどっちか。
それが-1か>=0かで処理が分かれる。

今気付いたんだけど（気付いてしまったというか）垂線のやつ、点がactiveになってそこからいくつもの線に
垂線を下ろす事も出来そう。つまりactiveな点や線がないときは、点か線がヒットしてactiveになる、ただし
重なっているときは点が優先。そしてそのあとは点がactiveなら線をクリックすると点から線に垂線、線がactiveなら
点をクリックすると点から線に。そういう感じで。んー。

点をクリックして、他の点をクリックして、activeな点を中心とし、その点を通る円を描く、とか。

メソッドをオブジェクトにするという考え方。
